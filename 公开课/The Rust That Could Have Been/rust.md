# Marijn Haverbeke - The Rust That Could Have Been

https://www.youtube.com/watch?v=olbTX95hdbg

好的，这是对 Marijn Haverbeke 关于“Rust 语言中被移除的特性”的演讲的详细讲解。

这个演讲是一次回顾性的深入剖析，探讨了 Rust 在 1.0 版本稳定之前，一些曾经被认为是核心的、雄心勃勃的特性是如何被引入、实验，并最终被移除的。Haverbeke（作为早期核心团队成员）的核心论点是：**这种看似“浪费”的特性移除过程，实际上是语言设计走向成熟和成功的必要步骤。**

---

### 1. 引言：狂野的早期与设计哲学 (Introduction)

- **背景 (0:40)**：Haverbeke 介绍了 Rust 的发展历程，将其分为三个阶段：

  1.  **史前时期**：Graydon Hoare 个人独立开发的阶段。
  2.  **狂野时期 (2011-2012)**：Mozilla 组建团队，从 OCaml 编译器迁移到自举的 Rust 编译器。这是 Haverbeke 参与的时期，其特点是**快速迭代和破坏性变更**。团队可以在一天之内提出、实现并合并一个重大改动。
  3.  **稳定时期 (1.0 之后)**：以严格的**向后兼容**为原则，所有变更都通过缓慢、严谨的 RFC (Request for Comments) 流程进行。

- **核心设计哲学 (3:14)**：Haverbeke 强调，设计一个复杂的系统（如编程语言），除非是超级天才，否则无法预见所有特性之间的相互作用和影响。**必须通过实际构建和尝试，才能真正评估一个想法的好坏。** 因此，移除那些最终被证明不合适的复杂特性，是“一个健康的设计过程”，而非失败。

---

### 2. 四个被移除的“愿景”

演讲围绕四个被移除的核心特性展开，Haverbeke 解释了它们是什么，以及为什么移除它们是正确的决定。

#### 愿景一：类型状态 (Type State) (4:32)

- **是什么？(4:49)**：一种让编译器在类型之外，了解更多关于值的**状态**信息的系统。例如，编译器不仅知道一个值是 `Socket` 类型，还知道它当前是 `Open` 状态；或者一个 `Vec` 不仅是向量，而且是 `NonEmpty`（非空）的。
- **目标 (5:10)**：提供更强的静态安全保证。程序员可以将头脑中的“不变量”（invariants）告诉编译器，由编译器来检查。
- **如何实现？(8:24)**：通过**断言 (Predicates)** 和**检查 (Checks)**。
  - 开发者可以编写纯函数（`pure fn`）作为断言，如 `not_empty()`。
  - 函数可以声明**前置条件 (preconditions)** 和**后置条件 (postconditions)**。例如，`last()` 函数要求其参数必须满足 `not_empty` 断言。
  - 为了满足前置条件，开发者需要在代码中插入 `check` 语句，这会引入一个**运行时检查**，如果失败则 `panic`。
- **为什么被移除？(10:58)**：
  1.  **编译器能力有限**：编译器只能传递断言信息，但无法“理解”断言代码的内部逻辑。在 `let v = [1, 2];` 之后，虽然人能看出 `v` 是非空的，但编译器无法自行推断，仍然需要开发者手动 `check v.not_empty()`。
  2.  **静态保证的幻觉**：最终，它并没有提供强大的静态保证，反而导致代码中充斥着 `check` 语句，并将许多本应是编译时错误的问题推迟到了**运行时 `panic`**。
  3.  **不符合成本效益**：该系统带来的复杂性远大于其提供的价值。Haverbeke 认为这是一个“失败的实验”。

#### 愿景二：结构化类型系统 (Structural Typing) (11:44)

- **是什么？**：类型的兼容性由其“形状”或“结构”决定，而不是由其“名称”决定。这与 Rust 当前的**名义化类型系统 (Nominal Typing)** 相对。
  - **结构化结构体 (Structs) (12:35)**：一个 `struct` 类型仅仅是其字段集合的别名。你可以创建一个临时的、匿名的记录（record），只要它的字段类型和顺序与函数期望的 `Point` 类型完全一样，就可以传递给它。
  - **结构化对象 (Objects) (13:41)**：更加灵活。一个对象类型只要拥有目标接口类型所要求的**方法子集**，就被认为是兼容的。这提供了一种“经过检查的鸭子类型”。
- **为什么被移除？**
  1.  **性能开销 (15:27)**：结构化对象因为其动态性（编译器不知道其确切大小和布局），必须是**堆分配**的，并且方法调用必须通过**虚函数表 (v-table)** 进行，这带来了额外的性能开销。这与 Rust 追求“零成本抽象”的理念相悖。
  2.  **与 Trait 系统冲突 (17:14)**：这是最关键的原因。当 Rust 引入了更强大的、类似 Haskell Typeclass 的 Trait 系统后，结构化类型带来了**“孤儿规则” (Orphan Rule) 和一致性 (Coherency) 问题**。想象一下，两个完全不相关的库，恰好定义了两个结构完全相同的 `struct`。如果它们都想为这个结构实现同一个 Trait（比如 `ToString`），就会产生冲突。编译器无法确定应该使用哪个实现。为了保证 Trait 实现的全局唯一性和一致性，`struct` 和 `enum` 必须是名义化的。

#### 愿景三：轻量级进程 (Lightweight Processes / Green Threads) (18:01)

- **是什么？**：类似于 Go 语言的 Goroutine。开发者可以廉价地创建成千上万个“任务 (task)”，并用`同步的方式编写异步代码。语言运行时负责将这些任务调度到少量的操作系统线程上执行。`
- **实现挑战 (19:36)**：
  1.  **自定义调度器**：需要一个复杂的用户态任务调度器。
  2.  **分段栈 (Segmented Stacks) (20:53)**：为了让每个任务的初始栈非常小（从而可以创建很多任务），同时又能处理深度递归，Rust 引入了分段栈。当一个任务的栈空间用尽时，它会分配一个新的栈段并链接起来。
- **为什么被移除？(23:32)**：
  1.  **性能问题**：分段栈的切换是有开销的。如果一个高频循环恰好发生在栈段切换的临界点，会导致性能急剧下降。这是一种“有漏洞的抽象”。
  2.  **FFI (外部函数接口) 复杂性**：与 C 代码交互变得非常复杂。因为 C 代码不理解分段栈，所以在调用 C 函数前，Rust 必须切换到一个巨大的、连续的“大栈”上，这增加了大量复杂性。
  3.  **违背核心定位**：拥有一个庞大而复杂的运行时（调度器、分段栈管理等），使得 Rust 无法成为一门可以轻松嵌入 C 程序、甚至用来编写操作系统的“系统级”语言。移除它，是为了让 Rust 成为一门**几乎没有运行时 (almost runtimeless)** 的语言，从而能够真正与 C++ 在同一生态位竞争。

#### 愿景四：垃圾回收 (Garbage Collection - GC) (24:40)

- **是什么？**：早期 Rust 内置了一个可选的垃圾回收器（最初是带循环检测的引用计数）。大部分值仍在栈上，但开发者可以选择使用 GC 管理的指针。
- **为什么被移除？(25:51)**：
  - 原因与移除轻量级进程类似：**为了成为一门真正的系统编程语言**。
  - 内置 GC 同样需要一个复杂的运行时，并且在与非 GC 代码（如 C/C++）交互时会产生大量问题。
  - Patrick Walton 提出了一个革命性的想法：**我们可以完全去掉 GC**。Haverbeke 最初也觉得这很荒谬，但后来意识到，这正是让 Rust 能够**直接对标 C++** 的关键一步。
  - Rust 的`所有权和借用系统`最终被证明是管理内存的强大替代方案，虽然有时会更繁琐（如返回一个闭包的例子），但它换来了无与伦比的性能和控制力。

---

### 结论

Haverbeke 的演讲揭示了 Rust 设计理念的演进：从一个试图融合多种高级语言特性（类型状态、GC、绿色线程）的语言，最终收敛并专注于成为一门**没有运行时、零成本抽象、安全且高效的系统编程语言**。

每一次“放弃”都是一次“聚焦”，使得 Rust 能够在其核心目标领域——取代 C++——做到极致。这个过程证明了，伟大的设计往往不是功能的堆砌，而是经过深思熟虑的取舍。
