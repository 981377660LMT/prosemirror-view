# Marijn Haverbeke – Salvaging contentEditable: Building a Robust Rich Text Editor – Falsy Values 2015

https://www.youtube.com/watch?v=r6cn49vHCoU&t=2s

好的，这是对 Marijn Haverbeke 关于 ProseMirror 的演讲的详细讲解。

这个演讲深入剖析了 ProseMirror 这个富文本编辑器库的设计哲学、核心挑战以及其创新的解决方案。Haverbeke 详细阐述了为什么在浏览器中构建一个可靠、可扩展的富文本编辑器如此困难，并介绍了 ProseMirror 是如何通过一个严谨的架构来克服这些困难的。

以下是演讲核心内容的逐层分析：

---

### 1. 引言：ProseMirror 是什么？(Intro & ProseMirror)

- **定义 (0:13)**：ProseMirror 是一个 “What You See Is What You Mean” (WYSIWYM) 编辑器库。
  - **与 WYSIWYG 的区别**：它不关注“这个文本是 7 像素高的 Arial 字体”，而是关注“这是一个段落”、“这是一个标题”、“这是强调文本”。它致力于表达文档的**语义结构**，而不是其视觉表现。
- **核心特性**：
  1.  **可定制的文档模型 (1:41)**：这是 ProseMirror 的核心卖点。它允许开发者精确地定义编辑器支持的文档结构。你可以创建自定义的元素，如 GitHub 的 commit 链接、用户提及（user handles）等，并确保它们在数据模型中是结构化的实体，而不仅仅是魔法字符串。
  2.  **内置协同编辑 (2:46)**：从底层设计就支持多人实时协同编辑，能精确地同步不同用户之间的文档变更。
- **与 CodeMirror 的区别 (1:20)**：Haverbeke 明确区分了两个项目：CodeMirror 用于纯文本/代码编辑，而 ProseMirror 用于富文本/散文（prose）编辑。

---

### 2. 核心挑战：`contentEditable` 的“原罪” (ContentEditable)

Haverbeke 将演讲的大部分篇幅用于解释构建富文本编辑器的最大障碍：浏览器的 `contentEditable` 属性。

- **历史回顾 (3:32)**：

  - **1997 年，IE4**：引入了 `designMode`（使整个文档可编辑）和 `execCommand` API（如 `execCommand('bold')`）。
  - **2000 年，IE**：引入了 `contentEditable`，允许将单个 DOM 节点设为可编辑，这是一个巨大的进步。
  - **2003 年，Mozilla (Firefox)**：在竞争压力下，Mozilla 决定复制 IE 的功能，但他们“自作聪明地”做了一些细微的改动。例如，执行 `bold` 命令时，IE 添加 `<b>` 标签，而 Firefox 添加 `<span style="font-weight: bold;">`。**这就是跨浏览器不一致噩梦的开端。**
  - **现状**：尽管所有现代浏览器都支持 `contentEditable`，但其行为**从未被真正标准化**。它仍然是一个充满怪异行为、bug 和不可预测性的“黑盒子”。

- **为什么 `contentEditable` 既是“好东西”又是“坏东西”？**
  - **好的一面 (9:13)**：它是浏览器原生提供的、唯一能够实现富文本编辑（带样式、光标、选区）的机制。没有它，我们只能用 `<textarea>`，它只能处理无样式的纯文本。
  - **坏的一面 (10:17)**：
    1.  **未指定行为**：当用户在列表或表格中按回车键时会发生什么？不同浏览器的实现各不相同。
    2.  **不可预测的 DOM 变更**：浏览器和用户会“合谋”对你的 HTML 做出各种奇怪的修改。用户可以粘贴表格、图片，或者从页面其他地方拖拽内容进来，导致你的 DOM 结构变得面目全非。
    3.  **Bug 众多且无人关心**：历史上，浏览器厂商对修复 `contentEditable` 的 bug 并不积极，因为它是一个复杂且使用频率远低于其他功能的子系统。

---

### 3. 解决方案的演进与 ProseMirror 的选择

面对 `contentEditable` 的混乱，社区发展出了不同的应对策略。

- **方案一：完全自己实现（“绘制”编辑器）(12:31)**

  - **代表**：Ace、CodeMirror（早期版本）、Google Docs。
  - **做法**：完全放弃 `contentEditable` 的编辑功能。DOM 节点本身是不可编辑的。编辑器库自己绘制一个假的光标（一个闪烁的 `<div>`），拦截所有键盘和鼠标事件，然后手动计算和更新 DOM。
  - **优点**：完全控制，行为一致。
  - **缺点 (13:28)**：需要重新实现浏览器已经为你做好的所有事情，代价极高。
    - **双向文本 (BiDi)**：处理从右到左（如阿拉伯语）和从左到右文本的混合显示、光标移动和选区，是一个巨大的噩梦。
    - **屏幕阅读器 (Screen Readers)**：由于浏览器不知道这是一个“编辑区域”，无障碍支持（ARIA）会完全失效。
    - **移动端/触摸设备 (Mobile/Touch)**：在触摸设备上模拟原生的选区、复制/粘贴菜单和拖动句柄，几乎是不可能做到完美和原生的。

- **方案二：ProseMirror 的混合方法 (16:08)**
  - **核心思想**：取两家之长。我们告诉浏览器“这个区域是可编辑的”（`contentEditable=true`），从而**免费获得**原生的光标、选区、输入法（IME）、拼写检查和移动端交互。但是，我们**不允许浏览器直接修改 DOM**。
  - **工作流程**：
    1.  **分离数据与视图**：ProseMirror 维护一个自己内部的、完全受控的**文档模型 (Document Model)**。DOM 只是这个模型的一个**只读视图**。
    2.  **拦截事件**：拦截绝大多数用户输入事件（如键盘按键），并调用 `preventDefault()` 阻止浏览器的默认行为。
    3.  **更新模型**：将用户意图（如“输入字符 A”）转换为对内部文档模型的**事务性更新**。
    4.  **同步视图**：在内部模型更新后，计算出新旧模型之间的差异，并以最小化的方式**精确地更新 DOM**。
  - **结论 (17:34)**：这种方法绕过了 `contentEditable` 超过 80% 的“恐怖之处”，因为它不再让浏览器进行任何实际的编辑操作，从而杜绝了所有不可预测的 DOM 变更。

---

### 4. ProseMirror 的内部机制

- **文档模型 (The Document Model) (17:54)**

  - **树状结构**：类似于 DOM，是一个树形结构。
  - **持久化数据结构 (Persistent Data Structure) (18:13)**：文档是**不可变的 (immutable)**。任何更新都会创建一个新的文档对象，而不是修改旧的。这通过结构共享（structure sharing）实现，使得更新操作非常高效。
  - **扁平化的内容表示 (19:30)**：与 HTML 的深度嵌套不同，ProseMirror 将段落内的内容表示为一个**扁平的文本片段序列**，每个片段关联一组样式（marks）。这种表示法更易于程序操作和推理。

- **文档更新的代数 (Algebra of Document Updates) (23:45)**
  - **一等公民的更新对象 (20:23)**：文档更新（如“删除一个字符”、“插入一段文本”）本身也是一个**值（first-class object）**。
  - **原子操作**：所有用户操作都被翻译成这些原子化的、可预测的更新对象。
  - **位置映射 (Position Map) (24:17)**：每次更新都会生成一个“位置映射”，它可以告诉你旧文档中的一个位置在新文档中对应哪个位置。这是实现协同编辑和高级撤销功能的关键。
  - **协同编辑的实现 (25:34)**：当两个用户同时编辑时，如果出现冲突，客户端可以使用“位置映射”将自己的本地变更“变基 (rebase)”到远程变更之后，然后重试提交。这类似于 `git rebase` 的思想。
  - **高级撤销 (26:52)**：撤销操作不是简单地回滚到上一个状态，而是计算出上一步操作的“逆操作”，并将其应用到**当前**文档上。这确保了在协同编辑环境中，一个用户的撤销不会撤销掉其他用户的合法更改。

---

### 5. 总结与未来 (Conclusion)

- ProseMirror 通过一个**受控的、不可变的文档模型**，并结合对 `contentEditable` 的巧妙利用（只用其“壳”，不用其“核”），成功地在一个混乱的环境中建立起了一套严谨、可靠且功能强大的富文本编辑框架。
- **未来的希望 (27:34)**：Haverbeke 提到，W3C 正在制定一个新规范，旨在将 ProseMirror 的这种模式标准化：提供一个 `contentEditable` 模式，它只提供输入事件而不实际修改 DOM，让 JavaScript 库来全权处理编辑逻辑。如果这个规范能够被采纳，将极大地简化未来富文本编辑器的开发。
