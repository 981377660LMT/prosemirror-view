# [JSConfEU 2011] Marijn Haverbeke: DOM implementation techniques

https://www.youtube.com/watch?v=FwPtnR5Fxf0&t=1s

好的，这是对 Marijn Haverbeke 关于“浏览器如何实现和优化 DOM”的演讲的详细讲解。

这个演讲深入浅出地剖析了现代浏览器在将 HTML 和 CSS 转换为屏幕上可见像素的过程中所经历的核心步骤，以及为了实现高性能和流畅体验而采用的关键优化策略。

以下是演讲核心内容的逐层分析：

---

### 1. 引言：为 DOM “正名” (Intro)

- **核心观点 (0:44)**：Haverbeke 首先提出了一个核心论点：尽管开发者经常抱怨，但 DOM 实际上是一个非常强大和优秀的平台。它提供了一种声明式的方式来定义文档，并允许脚本对其进行完全的检查和操作，而这一切都经过了高度优化。

---

### 2. 核心渲染流水线 (The Rendering Pipeline)

演讲将从解析到显示的过程分解为三个主要阶段。

#### 阶段一：构建渲染树 (Render Tree) (2:11)

- **是什么**：浏览器在拥有 DOM 树和样式规则后，并不会直接渲染 DOM 树。它会构建一个名为“渲染树”（或布局树）的新树。
- **与 DOM 树的区别**：
  1.  **不可见元素被移除**：`display: none` 的节点不会出现在渲染树中。
  2.  **结构重组**：渲染树更关注**空间关系**。例如，一个 `position: absolute` 的元素会被从其在 DOM 中的原始位置“提升”到其定位父级（第一个 `position` 不为 `static` 的祖先）的子节点中。`position: fixed` 的元素则会被直接提升到树的顶层。
- **目的**：渲染树更紧密地对应于屏幕上实际将要绘制的矩形区域及其布局依赖关系。

#### 阶段二：布局 (Layout / Reflow) (3:14)

- **是什么**：遍历渲染树，为每个可见节点计算其在屏幕上的精确几何信息——**尺寸（宽/高）和位置（x/y 坐标）**。
- **过程 (3:45)**：
  - 通常是一个**自顶向下**的过程。父节点确定其子节点的可用宽度。
  - 子节点根据可用宽度进行布局（例如，内联元素会进行换行），然后计算出自己的高度。
  - 这个高度信息再被返回给父节点，用于布局后续的兄弟节点。
- **复杂情况 (4:23)**：表格（`<table>`）是一个特例。由于单元格的尺寸相互依赖，浏览器通常需要进行**多次遍历**才能确定最终布局，这也是为什么复杂的表格布局性能较差的原因之一。

#### 阶段三：绘制 (Drawing / Painting) (5:06)

- **是什么**：在布局完成后，浏览器知道了每个元素的确切位置和样式。绘制阶段就是遍历渲染树，调用底层的绘图 API，将这些元素的像素实际填充到屏幕上。这个过程会考虑 `z-index` 等堆叠顺序。

---

### 3. 动态变化与优化策略

现代网页不是静态的。浏览器必须高效地处理由脚本、用户交互（如 `:hover`）或增量加载引起的 DOM 变化。

#### 3.1. 重排 (Reflow) 与重绘 (Repaint)

- **重排 (Reflow)**：当一个元素的几何属性（如宽度、高度、位置）发生变化，影响到其他元素的布局时，浏览器需要重新运行**布局**过程。这是一个潜在开销很大的操作。
- **重绘 (Repaint)**：当一个元素的非几何属性（如颜色、背景、`visibility`）发生变化，不影响布局时，浏览器只需重新**绘制**该元素，跳过布局阶段。这个开销相对较小。

#### 3.2. 关键优化一：懒惰布局 (Lazy Layout) (9:33)

- **核心思想**：当脚本修改 DOM 时，浏览器**不会立即**执行重排。它会将受影响的节点标记为“脏”(dirty)。
- **批量处理**：浏览器会等到脚本执行完毕后（在理想情况下），再一次性地对所有“脏”节点进行布局计算。如果一个脚本进行了 100 次修改，但这些修改都影响同一片区域，这种策略可以将 100 次重排合并为 1 次，极大地节省了性能。

#### 3.3. 性能陷阱：强制同步布局 (Forced Synchronous Layout) (10:16)

- **是什么**：这是“懒惰布局”优化的一个例外。如果脚本在修改 DOM 后，**立即读取**需要精确布局信息的属性（如 `offsetTop`, `clientWidth`, `getComputedStyle().width`），浏览器为了返回正确的值，**必须立即强制执行**待处理的布局操作。
- **最坏情况 (10:32)**：在一个循环中，每次迭代都先修改 DOM，然后又读取布局信息。这会导致**每次循环都强制进行一次重排**，使得“懒惰布局”优化完全失效，造成严重的性能问题。
- **Haverbeke 的例子 (10:54)**：他以 CodeMirror 编辑器中的行号栏为例，通过重构代码，避免在循环中读取高度，将一个耗时数秒的操作优化到了 3 毫秒，展示了避免强制同步布局的巨大威力。

---

### 4. 绘制优化：硬件加速与图层 (Layers)

#### 4.1. 硬件加速 (12:01)

- **核心思想**：利用 GPU 的强大能力来加速绘制过程，而不是完全依赖 CPU 进行软件绘制。
- **图层 (Layers) (12:35)**：浏览器会将渲染树中符合特定条件的某些部分“提升”为独立的图层。这些图层会被当作纹理（textures）发送给 GPU。
  - **提升条件**：通常是应用了 `transform: 3d`, `will-change`, `<video>` 元素等。
- **优势**：
  1.  **动画与滚动 (13:16)**：对于一个已经绘制好的图层，后续的滚动或 `transform` 动画（位移、旋转、缩放）可以直接在 GPU 上完成，无需 CPU 重新计算布局和绘制，因此极为流畅。
  2.  **独立重绘**：如果一个图层的内容发生变化，只需要重绘这一个图层，不会影响到其他图层。

#### 4.2. 为什么 3D Transform 比 2D 更快？(14:24, 19:25)

- 这是一个常见的观察。Haverbeke 和提问者探讨了原因：当使用 `transform: translate3d(...)` 或其他 3D 变换时，浏览器会更倾向于为该元素创建一个独立的**合成层 (Composited Layer)**，并将其交给 GPU 处理。而 2D 变换在某些旧的实现中可能仍在 CPU 的绘制流程中处理。本质上，3D 变换是一个强制开启 GPU 加速的“黑魔法”。

---

### 5. 样式匹配优化 (Style Matching) (14:50)

- **问题**：在布局之前，浏览器需要为成千上万个 DOM 节点，从可能成千上万条 CSS 规则中，找出所有适用的规则。朴素的 `节点数 * 规则数` 算法是不可接受的。
- **解决方案：桶分类 (Buckets) (16:12)**：
  - 浏览器在解析样式表时，会根据每条规则的**最右侧选择器 (rightmost selector)**，将规则放入四个桶中：
    1.  **ID 桶**：按 ID 索引 (`#my-id`)
    2.  **Class 桶**：按类名索引 (`.my-class`)
    3.  **标签名桶**：按标签名索引 (`div`)
    4.  **通用桶**：其余所有规则（如 `*`, `[href]`, `:hover`）
  - **匹配过程 (17:02)**：当为一个节点匹配样式时，浏览器不再遍历所有规则，而是：
    1.  根据节点的 ID，直接去 ID 桶里查找。
    2.  根据节点的每个 class，去 Class 桶里查找。
    3.  根据节点的标签名，去标签名桶里查找。
    4.  最后，遍历通用桶里的所有规则。
- **结论**：这个策略将需要检查的规则数量减少了几个数量级，使得样式匹配过程非常高效。同时，这也启示开发者应尽量避免使用低效的通用选择器。
