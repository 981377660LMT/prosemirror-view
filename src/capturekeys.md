好的，我们来深入讲解 capturekeys.ts 这个文件。

这个文件可以被理解为 ProseMirror 视图层的 **“键盘事件的最后防线”** 或 **“浏览器行为矫正器”**。它的核心职责是在用户自定义的 `keymap` 插件之前，捕获并处理最基本、最关键的键盘事件（主要是光标导航和删除），以确保在所有浏览器中都有一个统一、可预测、无 bug 的基础行为。

### 核心设计思想：在用户之前，驯服浏览器

ProseMirror 的 `keymap` 插件允许用户将任意按键绑定到命令上。但如果一个命令返回 `false`（表示它没有处理该事件），事件的控制权就会交还给浏览器。而浏览器在 `contenteditable` 环境下的默认行为充满了各种 bug 和不一致性，尤其是在处理非文本节点、块级边界和复杂选区时。

capturekeys.ts 的存在就是为了解决这个问题。它在 `keymap` 之前运行，扮演一个“安全网”的角色，其主要目标有三个：

1.  **阻止破坏性行为**: 强制拦截某些按键（如退格、删除），防止浏览器在 ProseMirror 不期望的情况下删除内容（例如，错误地删除整个节点）。
2.  **确保平滑导航**: 实现可靠的光标导航，让用户可以用方向键在文本、原子节点（如图片）和块级节点之间无缝移动，即使浏览器本身不支持这种行为。
3.  **修复特定浏览器 Bug**: 包含大量针对特定浏览器（尤其是 Webkit/Safari 和 Gecko/Firefox）的 hack 和变通方法，以修复已知的键盘行为 bug。

---

### `captureKeyDown(view, event)`: 事件处理中心

这是该文件的入口和核心。它像一个巨大的 `switch` 语句，根据按下的键（`event.keyCode`）和修饰键（`mods`）来分发处理逻辑。

我们来分析几个关键按键的处理流程：

#### 1. 水平导航：左/右方向键 (`selectHorizontally`)

这是最能体现其复杂性的部分。当用户按下左/右箭头时，`selectHorizontally` 会根据当前选区类型执行不同逻辑：

- **当选区是文本光标时 (`TextSelection` 且 `empty`)**:
  - **情况一：光标在文本块的边界** (`view.endOfTextblock(...)`)。
    - 它会调用 `moveSelectionBlock`，尝试在当前块的“外面”寻找下一个可选中的位置。如果旁边是一个可选中的节点（如图片），它会创建一个 `NodeSelection` 来选中该节点。这就是你如何能从段落末尾通过按右箭头直接选中下一张图片。
  - **情况二：光标旁边是一个原子节点 (atom node)**（例如，一个行内图片或 mention 标签）。
    - 如果该节点是可被 `NodeSelection` 选中的，它会立即创建一个 `NodeSelection`。
    - 如果不可选，但在 Webkit 浏览器中，它会创建一个新的 `TextSelection`，将光标直接“跳”到该节点的另一侧。这是为了修复 Chrome/Safari 会在不可编辑的行内节点周围产生多个无用光标位置的 bug。
- **当选区是一个节点选区时 (`NodeSelection`)**:
  - 如果选中的是一个行内节点，按左/右箭头会取消节点选中状态，并将选区转换为节点旁边的一个文本光标。

#### 2. 垂直导航：上/下方向键 (`selectVertically`)

垂直导航的逻辑相对简单，主要处理块级节点之间的移动。

- **核心逻辑**: 如果光标已经位于文本块的顶部或底部 (`view.endOfTextblock(...)`)，它会尝试调用 `moveSelectionBlock` 来创建一个 `NodeSelection`，以选中上一个或下一个块级节点。
- **Bug 修复 (`safariDownArrowBug`)**: 包含一个专门针对 Safari 的 hack。在 Safari 中，如果光标在一个文本块的开头，且后面紧跟着一个不可编辑的节点，按向下箭头会导致非常奇怪的选区行为。这个函数会临时将那个不可编辑的节点设为 `contenteditable="true"`，让浏览器执行默认行为，然后再立刻设回 `"false"`，以此绕过这个 bug。

#### 3. 删除键：退格/删除 (`stopNativeHorizontalDelete`)

这里的核心目标是防止浏览器在 ProseMirror 模型不知情的情况下破坏文档结构。

- **核心逻辑**: 它会检查光标是否紧邻一个非文本节点。如果是，它不会让浏览器自己去处理删除，而是会创建一个 ProseMirror 的 `Transaction` 来精确地删除那个节点，然后 `dispatch` 这个事务。这样保证了视图和状态的绝对同步。
- **边界情况**: 如果光标在文本块的开头或结尾，它也会阻止浏览器的默认行为，因为这通常会导致合并或删除整个块，这些行为应该由 ProseMirror 的命令（如 `joinBackward`）来精确控制。

---

### 核心辅助函数：`skipIgnoredNodes`

这是另一个非常重要的部分，用于处理 ProseMirror 视图中的“幽灵节点”。

- **什么是“被忽略的节点” (`isIgnorable`)**: 在 ProseMirror 中，某些 `NodeView` 可以渲染出在文档模型中没有对应大小的 DOM 元素（例如，零宽度的 widget、空的 `<span>` 等）。这些节点对于浏览器来说是可见的，但对于 ProseMirror 的位置计算来说是“隐形”的。
- **问题**: 浏览器的光标导航逻辑不知道这些节点是“隐形”的，它可能会把光标定位在这些节点旁边，导致 ProseMirror 的状态与 DOM 选区不匹配，引发各种问题。
- **`skipIgnoredNodes(view, dir)` 的作用**: 在执行键盘导航后，这个函数会被调用。它会检查当前 DOM 光标的位置，如果发现光标恰好落在一个或多个“被忽略的节点”旁边，它会以编程方式（`setSelFocus`）将光标移动到下一个“有效”的位置。
- **效果**: 确保了 DOM 光标永远不会停留在对 ProseMirror 模型来说没有意义的位置，从而避免了大量的浏览器兼容性问题。

### 总结

capturekeys.ts 是 ProseMirror 健壮性的一个缩影。它体现了开发一个可靠的所见即所得编辑器的核心挑战：你不能完全信任浏览器。

通过在底层建立一个强大的“矫正层”，`capturekeys.ts` 做了以下几件事：

1.  **定义了基础行为**: 它为最核心的导航和删除操作提供了一个跨浏览器一致的、可预测的基础。
2.  **增强了用户体验**: 实现了在复杂内容（如混合文本和原子节点）之间流畅导航的能力。
3.  **隔离了复杂性**: 它将大量丑陋的、针对特定浏览器的 hack 封装在这个底层文件中，使得上层的插件和业务逻辑可以编写得更加干净和纯粹。

当你使用 ProseMirror 并发现光标导航“就是好用”时，很大程度上要归功于 capturekeys.ts 在幕后所做的这些细致而繁琐的工作。
